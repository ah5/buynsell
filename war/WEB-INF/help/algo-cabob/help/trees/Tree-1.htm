<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Tree-1</title></head>

<body>

<center><b><font size="+1"><a href="http://www.cis.temple.edu/%7Epwang/223-DS/CIS223.htm">
0223. Data Structures and Algorithms</a></font></b>
<p><b><font size="+2">Trees (1)</font></b></p></center>

<p>&nbsp;</p>
<h3> 1. Trees</h3>
Assume we have items called "nodes", each keeping certain data, and
there are links representing a relations among nodes, each coming from
a "predecessor", and going to a "successor". The nodes and links form a
data structure.
<p> 
In a tree, each node may have multiple successors, but only one predecessor, 
except one node which has no predecessor, and is called the "root" of the tree. 
Usually the order of successors matters.
</p><p>
Properties of tree:
</p><ul>
  <li>each node is connected to a <i>root</i> node by a unique path,</li>
  <li>the links do not form a cycle.</li>
</ul>
Terminology: <i>branches, children, parent, sibling, leaf, external/internal nodes, 
ancestor-descendant relationship, subtree, level, height.</i>
[see the textbook, pages 389--390].
<p>In implementation, usually each node contains references to its
children. For certain applications, it is possible to use an
"upside-down" tree, where each node contains one reference to its
parent. Which structure should be used depends on the desired access
path --- from predecessor to successor, or the other way around. </p><p>
Examples of trees: arithmetic expressions, file systems, the Java class hierarchy.
</p><p>
The convention followed when drawing a tree: root at the top, or links from parents
to children. Example:
</p><pre>              A
            / | \
           B  C  D			 
         / |  |
        E  F  G
</pre>

<p>&nbsp;</p>
<h3> 2. Binary trees</h3>

If each node in a tree contains exactly two references, the tree is called a binary 
tree. Because reference can be null, each node in a binary tree can have 0, 1, or 2 
successor nodes. Example:
<pre>              A
             /
            B     			 
           / \
          E   C
          \  / \
          F G   D
</pre>
<a href="http://www.cis.temple.edu/%7Epwang/223-DS/K-W/Ch8/BinaryTree.java">A sample implementation of binary tree</a>.
<p>
A binary tree is <i>full</i> if all of its leaves are on the same level, and all internal
nodes have exactly two children. A full binary tree with height <tt>h</tt> has 
<tt>2^h - 1</tt> nodes. A binary tree is <tt>complete</tt> if all the "holes"
are on the right side of the deepest level.
</p><p>
A binary tree can also be stored in an array in the following way: first, put
the root in index 0, then, for every node in index <i>i</i>, put its left child 
at <i>2i+1</i>, and its right child at <i>2i+2</i>. In this way, the above binary
tree will be represented as 
</p><pre>{A, B, _, E, C, _, _, _, F, G, D}.</pre>
The "_" in the array is a special value indicating nonexistent values, or "holes". 
In Java, for class variables, it is "<i>null</i>", and for real numbers, it is 
"<i>NaN</i>" (for "not a number"), a static value defined in classes <i>Double</i> 
(with type <i>double</i>) and <i>Float</i> (with type <i>float</i>). If the binary 
tree is complete, then there is no "hole" when it is stored in an array between nodes.
<p>
Array implementation for binary tree is not efficient for insertion and deletion.
</p><p>
Although we study only binary trees, this is really sufficient because we can 
represent any general tree using a binary tree in this way: point a node's left 
link to its first child, and point a node's right link to its next sibling. 
Example:
</p><pre>              A                           A
            / | \                        /
           B  C  D       ==&gt;            B     			 
         / |  |                        / \
        E  F  G                       E   C
                                      \  / \
                                      F G   D
</pre>

<p>&nbsp;</p>
<h3>3. Tree traversal</h3>

Traversing a tree means visiting each node in a specified order. There are three 
simple ways to traverse a binary tree: <i>preorder, inorder, postorder,</i> all 
defined recursively.
<pre>   private void preOrder(Node node) {
      if(node != null) {
         node.visit();
         preOrder(node.left);
         preOrder(node.right);
      }
   }

   private void inOrder(Node node) {
      if(node != null) {
         inOrder(node.left);
         node.visit();
         inOrder(node.right);
      }
   }

   private void postOrder(Node node) {
      if(node != null) {
         postOrder(node.left);
         postOrder(node.right);
         node.visit();
      }
   }
</pre>
These three methods are closely related to prefix, infix, and postfix expressions,
which were covered previously.
<p>
Traversing a tree as tracing the outline of the tree:
</p><ul>
  <li>For preorder traversal, display node contents as you pass it going down. </li>
  <li>For inorder traversal, display node contents as you pass under it. </li>
  <li>For postorder traversal, display node contents as you pass it going up.</li>
</ul>
Example:
<pre>                           A
                          / \
                         B   C
                        / \   \
                       D   E   F
                        \     / \
                         G   H   I
</pre>
<ul>
  <li>preorder visiting: A B D G E C F H I</li>
  <li>inorder visiting: D G B E A C H F I</li>
  <li>postorder visiting: G D E B H I F C A</li>
</ul>
For trees in general (i.e., not necessarily binary), preorder and postorder 
traversals are still well-defined, but inorder is not.<p></p>
<p>
The above traversal algorithms can be modified to do search: if a given key
is found during traversal, report "yes" and stop; at the end, report "no".
</p><p>
The complexity of a traversal is O(n). 

</p></body></html>