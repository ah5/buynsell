<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html><head><!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others --><title>Chapter 4: Trees</title>

<meta name="description" content="Chapter 4: Trees">
<meta name="keywords" content="slidesweb">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="STYLESHEET" href="node3_files/slidesweb.css">
<link rel="next" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node4.html">
<link rel="previous" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node2.html">
<link rel="up" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/slidesweb.html">
<link rel="next" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node4.html"></head>


<body>
<!--Navigation Panel-->
<a name="tex2html39" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node4.html">
<img alt="next" src="node3_files/next_motif.htm" align="bottom" border="0" height="24" width="37"></a> 
<a name="tex2html37" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/slidesweb.html">
<img alt="up" src="node3_files/up_motif.htm" align="bottom" border="0" height="24" width="26"></a> 
<a name="tex2html31" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node2.html">
<img alt="previous" src="node3_files/previous_motif.htm" align="bottom" border="0" height="24" width="63"></a>   
<br>
<b> Next:</b> <a name="tex2html40" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node4.html">Chapter 5: Hashing</a>
<b> Up:</b> <a name="tex2html38" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/slidesweb.html">CS 3345: Algorithm Analysis</a>
<b> Previous:</b> <a name="tex2html32" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node2.html">Chapter 3: Lists, Stacks</a>
<br>
<br>
<!--End of Navigation Panel-->

<h1><a name="SECTION00030000000000000000">
Chapter 4: Trees</a>
</h1>

<p>
        </p><div align="center">
<u><b>Trees</b></u>
        </div>        
<ul>
<li>collection of nodes and edges
</li><li>one <i>root</i> node
</li><li>zero or more subtrees
</li><li>roots of subtrees connected to <i>root</i> node
</li><li>parent-child relationship
</li><li>degree of a node = # of children
</li><li>internal nodes, leaf nodes
</li></ul>

<p>
        </p><div align="center">
<u><b>Trees</b></u>
        </div>        
<ul>
<li><i>n</i> nodes 
<!-- MATH: $\Rightarrow$ -->
<img src="node3_files/img11.gif" alt="$\Rightarrow$" align="bottom" border="0" height="14" width="19">
<i>n</i>-1 edges
</li><li><em>path length:</em> # of edges in the path
</li><li><em>node depth:</em> path length from root
</li><li><em>node height:</em> max path length to a leaf
</li><li><em>tree height:</em> height of root
</li></ul>
<p>
<em>Implementation:</em> linked list of pointers for <br>
children


</p><p>
        </p><div align="center">
<u><b>Hierarchical File System</b></u>
        </div>        
<ul>
<li>tree structure
</li><li>pathname: directories traversed from top
</li><li>file: uniquely identified by pathname
</li></ul>
<!-- MATH: $\Rightarrow$ -->
<img src="node3_files/img11.gif" alt="$\Rightarrow$" align="bottom" border="0" height="14" width="19">
file name need not be unique


<p>
        </p><div align="center">
<u><b>Tree Traversals</b></u>
        </div>        
<dl>
<dt><strong>Preorder traversal:</strong>
</dt><dd>node first, children later
<ul>
<li>running time = <i>O</i>(<i>n</i>)</li></ul></dd><dt><strong>Inorder traversal:</strong>
</dt><dd>consider a binary tree
<ul>
<li>traverse left subtree
</li><li>process current node
</li><li>traverse right subtree
</li></ul></dd><dt><strong>Postorder traversal:</strong>
</dt><dd>subtrees first, <br>
node later
</dd></dl>

<p>
        </p><div align="center">
<u><b>Binary Trees</b></u>
        </div>        
<ul>
<li>at most 2 children/node
</li><li>linked list implementation: three fields
<dl compact="compact">
<dt>1.
</dt><dd>value
</dd><dt>2.
</dt><dd>left child pointer
</dd><dt>3.
</dt><dd>right child pointer
</dd></dl></li></ul><em>Expression Trees
</em><ul>
<li>operands = leaf nodes
</li><li>operators = internal nodes
</li><li>degree of internal node = # of operands required by operator
</li></ul>

<p>
        </p><div align="center">
<u><b>
<br>
Expression Tree Construction</b></u>
        </div>        
<b>Input:</b> postfix expression
<br>
<u>Rules</u>
<dl compact="compact">
<dt>1.
</dt><dd>
<br>
read one symbol at a time
</dd><dt>2.
</dt><dd>operand:
<ul>
<li>create one-node tree
</li><li>push pointer onto stack
</li></ul></dd><dt>3.
</dt><dd>operator:
<ul>
<li>pop pointers to <i>T</i><sub>1</sub> and <i>T</i><sub>2</sub>
</li><li>form a new tree
</li><li>root = operator
</li><li>left child = <i>T</i><sub>2</sub>, right child = <i>T</i><sub>1</sub>
</li><li>push new tree's pointer onto stack
</li></ul></dd></dl>

<p>
        </p><div align="center">
<u><b>Binary Search Trees</b></u>
        </div>        
<ul>
<li>each node has a key
</li><li>assume distinct keys
</li><li>keys in left subtree &lt; current node
</li><li>current node &lt; keys in right subtree
</li><li>average depth = O(log n)
</li></ul>

<p>

</p><div align="center">
<u><b>Make_Empty</b></u>
</div><pre>/* 1*/  template &lt;class Etype&gt;
/* 2*/  void
/* 3*/  Binary_Search_Tree&lt;Etype&gt;::
/* 4*/  Make_Empty( Tree_Node&lt;Etype&gt; * &amp; T)
/* 5*/  {
/* 6*/      if( T != NULL)
/* 7*/      {
/* 8*/          Make_Empty( T-&gt;Left);
/* 9*/          Make_Empty( T-&gt;Right);
/*10*/          delete T;
/*11*/          T = NULL;
/*12*/      }
/*13*/  }
</pre>
<p>

</p><div align="center">
<u><b>Find</b></u>
</div><pre>/* 1*/template &lt;class Etype&gt;
/* 2*/Tree_Node&lt;Etype&gt;*
/* 3*/Binary_Search_Tree&lt;Etype&gt;::
/* 4*/Find(const Etype &amp;X, Tree_Node&lt;Etype&gt; *T)
/* 5*/{
/* 6*/    if( T == NULL)
/* 7*/        return NULL;
/* 8*/    else
/* 9*/    if( X &lt; T-&gt;Element)
/*10*/        return Find( X, T-&gt;Left);
/*11*/    else
/*12*/    if( X &gt; T-&gt;Element)
/*13*/        return Find( X, T-&gt;Right);
/*14*/    else
/*15*/        return T;
/*16*/}
</pre>
<p>

</p><div align="center">
<u><b>Find_Min, FInd_Max</b></u>
</div><pre>/* 1*/  template &lt;class Etype&gt;
/* 2*/  Tree_Node&lt;Etype&gt;*
/* 3*/  Binary_Search_Tree&lt;Etype&gt;::
/* 4*/  Find_Min( Tree_Node&lt;Etype&gt; *T) const
/* 5*/  {
/* 6*/      if( T == NULL)
/* 7*/          return NULL;
/* 8*/      else
/* 9*/      if( T-&gt;Left == NULL)
/*10*/          return T;
/*11*/      else
/*12*/          return Find_Min( T-&gt;Left);
/*13*/  }
</pre>
<p>

</p><div align="center">
<u><b>Insert</b></u>
</div><pre>/* 1*/template &lt;class Etype&gt;
/* 2*/void Binary_Search_Tree&lt;Etype&gt;::
/* 4*/Insert(const Etype&amp;X, Tree_Node&lt;Etype&gt;*&amp;T)
/* 5*/{
/* 6*/    if( T == NULL)
/* 7*/    {
/* 8*/        T = new Tree_Node&lt;Etype&gt;(X);
/* 9*/        if( T == NULL )
/*10*/            Error( "Out of space");
/*11*/    }
/*12*/    else
/*13*/    if( X &lt; T-&gt;Element)
/*14*/        Insert( X, T-&gt;Left);
/*15*/    else
/*16*/    if( X &gt; T-&gt;Element)
/*17*/        Insert( X, T-&gt;Right);
/*18*/    // Else X is in the tree already.
/*19*/}
</pre>
<p>
        </p><div align="center">
<u><b>Remove</b></u>
        </div>        
<ul>
<li>leaf node: delete immediately
</li><li>node with one child: 
<ul>
<li>adjust parent's pointer to bypass node
</li><li>delete node
</li></ul>
</li><li>node with two children:
<ul>
<li>replace with smallest node in right <br>
subtree
</li><li>delete node
</li></ul></li></ul>

<p>
        </p><div align="center">
<u><b>Balancing the Tree</b></u>
        </div>        
<ul>
<li>additions, deletions 
<!-- MATH: $\Rightarrow$ -->
<img src="node3_files/img11.gif" alt="$\Rightarrow$" align="bottom" border="0" height="14" width="19">
create imbalance
</li><li>if insertion input presorted: insertion takes quadratic time!
</li><li>need for imposing <em>balance</em>
</li></ul><u>Two approaches</u>
<dl compact="compact">
<dt>1.
</dt><dd>insist on balance: no node allowed to go too deep 
</dd><dt>2.
</dt><dd>forgo balance: apply restructuring rule to make future operations
efficient
</dd></dl>Restructuring example: a sequence of <i>m</i> <br>
operations take <em>O(m log n)</em>
time


<p>
        </p><div align="center">
<u><b>Balancing: the battle continues</b></u>
        </div>        
<dl>
<dt><strong>Simplest idea:</strong>
</dt><dd>left and right subtrees have same height
<ul>
<li>doesn't work all the time
</li></ul></dd><dt><strong>Alternative:</strong>
</dt><dd>for every node, left subtree height = right subtree height
<ul>
<li>too rigid
</li><li>requires perfect balance
</li></ul></dd></dl>Need a compromise between the two <br>
approaches


<p>
        </p><div align="center">
<u><b>AVL Trees</b></u>
        </div>        
<ul>
<li>similar to binary search trees
</li><li>difference: for every node left and right subtrees can have height
	difference of at most 1
</li><li>height of an AVL tree = at most 1.44 log n (approx.)
</li></ul><i>N</i>(<i>h</i>): # of nodes in minimum size AVL tree of height <i>h</i>
<br>

<!-- MATH: $N(h) = N(h-1) + N(h-2) + 1$ -->
<i>N</i>(<i>h</i>) = <i>N</i>(<i>h</i>-1) + <i>N</i>(<i>h</i>-2) + 1
<br>
<i>N</i>(0) = 1,   <i>N</i>(1) = 2
<br>
<br>
<br>
<br>
all operations, except insertion, performed in <i>O</i>(<i>log</i>&nbsp;<i>N</i>) time


<p>
        </p><div align="center">
<u><b>Balancing Procedure</b></u>
        </div>
Insertion can unbalance the tree
<br>
<br>
<br>
<br>
Restore balance by rotation
<dl compact="compact">
<dt>1.
</dt><dd>start at inserted node
</dd><dt>2.
</dt><dd>travel upwards updating balance <br>
information
</dd><dt>3.
</dt><dd>if root reached without need for balancing: done
</dd><dt>4.
</dt><dd>otherwise: do a rotation at first badly <br>
balanced node encountered
</dd><dt>5.
</dt><dd>done!
</dd></dl>

<p>
        </p><div align="center">
<u><b>Splay Trees</b></u>
        </div>        
<ul>
<li>any <i>m</i> consecutive tree operations take <br>
<!-- MATH: $O(m~log~n)$ -->
<i>O</i>(<i>m</i>&nbsp;<i>log</i>&nbsp;<i>n</i>) time
</li><li>amortized running time per tree operation = <i>O</i>(<i>log</i>&nbsp;<i>n</i>)</li></ul><u><b>Basic Idea:</b></u> an accessed node is pushed to the root by a series 
of AVL tree rotations <br>
<br>
<br>
<u><b>Effect:</b></u> if accessed node is very deep, <br>
restructuring results in
tree balancing
<br>
<br>
<br>
<u><b>Simple solution:</b></u> perform single rotations <br>
bottom up 
(<em>doesn't work!</em>)
<br>
<br>
<br>
<u><b>Reason:</b></u> it may push other nodes almost as deep as the raised 
node used to be


<p>
        </p><div align="center">
<u><b>Splaying</b></u>
        </div>        
<ul>
<li>similar to rotations
</li><li>greater selectivity about how to rotate
</li></ul><u><b>Splaying Rules</b></u>
<dl compact="compact">
<dt>1.
</dt><dd>travel bottom up along access path
</dd><dt>2.
</dt><dd>let <i>X</i> be node to be rotated
<ul>
<li>if parent(<i>X</i>) = root 
<!-- MATH: $\Rightarrow$ -->
<img src="node3_files/img11.gif" alt="$\Rightarrow$" align="bottom" border="0" height="14" width="19">
rotate <i>X</i> and root
</li><li>if <i>X</i> has grandparent and <em>zig zag</em> <br>
<!-- MATH: $\Rightarrow$ -->
<img src="node3_files/img11.gif" alt="$\Rightarrow$" align="bottom" border="0" height="14" width="19">
double rotation
like AVL
</li><li>if <i>X</i> has grandparent and <em>straight path</em> 
<!-- MATH: $\Rightarrow$ -->
<img src="node3_files/img11.gif" alt="$\Rightarrow$" align="bottom" border="0" height="14" width="19">
change 
orientation
</li></ul></dd></dl>

<p>
        </p><div align="center">
<u><b>Splaying: Properties</b></u>
        </div>        
<dl compact="compact">
<dt>1.
</dt><dd>when access paths are long:
<ul>
<li>longer than normal search time
</li><li>rotations tend to be good for future operations
</li></ul></dd><dt>2.
</dt><dd>when accesses are cheap: rotations not as good
</dd></dl>

<p>
        </p><div align="center">
<u><b>B-Trees</b></u>
        </div>        
<ul>
<li>root: either a leaf of has 2-<i>m</i> children
</li><li>non-leaf, non-root nodes: 
<!-- MATH: $\lceil \frac{m}{2} \rceil - m$ -->
<img src="node3_files/img26.gif" alt="$\lceil \frac{m}{2} \rceil - m$" align="middle" border="0" height="31" width="66">
children
</li><li>all leaves at same depth
</li><li>data stored in the leaves
</li><li>intermediate nodes contain pointer to children and smallest values in
subtrees
</li><li>values in subtree <i>p</i><sub>1</sub> &lt; values in subtree <i>p</i><sub>2</sub> &lt; ...
</li><li># of values in a leaf: 
<!-- MATH: $\lceil \frac{m}{2} \rceil - m$ -->
<img src="node3_files/img26.gif" alt="$\lceil \frac{m}{2} \rceil - m$" align="middle" border="0" height="31" width="66">
</li><li>depth of a B-tree: 
<!-- MATH: $\lceil log_{\lceil \frac{m}{2} \rceil} n \rceil$ -->
<img src="node3_files/img27.gif" alt="$\lceil log_{\lceil \frac{m}{2} \rceil} n \rceil$" align="middle" border="0" height="31" width="73"></li></ul>

<p>
</p><hr>
<!--Navigation Panel-->
<a name="tex2html39" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node4.html">
<img alt="next" src="node3_files/next_motif.htm" align="bottom" border="0" height="24" width="37"></a> 
<a name="tex2html37" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/slidesweb.html">
<img alt="up" src="node3_files/up_motif.htm" align="bottom" border="0" height="24" width="26"></a> 
<a name="tex2html31" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node2.html">
<img alt="previous" src="node3_files/previous_motif.htm" align="bottom" border="0" height="24" width="63"></a>   
<br>
<b> Next:</b> <a name="tex2html40" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node4.html">Chapter 5: Hashing</a>
<b> Up:</b> <a name="tex2html38" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/slidesweb.html">CS 3345: Algorithm Analysis</a>
<b> Previous:</b> <a name="tex2html32" href="http://www.utdallas.edu/%7Eravip/cs3345/slidesweb/node2.html">Chapter 3: Lists, Stacks</a>
<!--End of Navigation Panel-->
<address>
<i>Ravi Prakash</i>
<br><i>1999-11-17</i>
</address>
</body></html>